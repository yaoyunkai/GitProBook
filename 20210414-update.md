## 1. FQA ##

### 查看已暂存和未暂存的修改 ###

查看未暂存的文件的修改(不包括未跟踪的文件)：

```shell
$ git diff
diff --git a/file1.txt b/file1.txt
index f164b71..808cf05 100644
--- a/file1.txt
+++ b/file1.txt
@@ -1,3 +1,4 @@
 hello world
 hello world
+hello world
```

 `git diff --staged`   `git diff --cached` 这条命令将比对已暂存文件与最后一次提交的文件差异：

```shell
$ git diff --staged
diff --git a/file1.txt b/file1.txt
new file mode 100644
index 0000000..f164b71
--- /dev/null
+++ b/file1.txt
@@ -0,0 +1,3 @@
+hello world
+hello world
+

```

### 移除文件 ###

从暂存区移除文件： `git rm`

```shell
Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git rm file1.txt
rm 'file1.txt'

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        deleted:    file1.txt


Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git diff

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git diff --cached
diff --git a/file1.txt b/file1.txt
deleted file mode 100644
index 808cf05..0000000
--- a/file1.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-hello world
-hello world
-hello world
-
```

**另一种情况：把文件从git仓库中删除，但仍然希望保留在当前工作目录中** `git rm --cached [filename]`

### git log 的用法 ###

```shell
Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git log -p -2
commit fe2ddd087ee22c4ab3a58eff4c1e27b5c4bfa5a2 (HEAD -> master)
Author: yunk <1052433260@qq.com>
Date:   Wed Apr 14 20:05:15 2021 +0800

    update gitignore

diff --git a/.gitignore b/.gitignore
index f7b7d41..9230a88 100644
--- a/.gitignore
+++ b/.gitignore
@@ -141,3 +141,5 @@ cython_debug/

 .idea/
 *.iml
+
+BigFile.txt

commit 403566622121ba571ca3b49823fafe9e0a0d1b91
Author: yunk <1052433260@qq.com>
Date:   Wed Apr 14 20:03:38 2021 +0800

    not track Bigfile

diff --git a/BigFile.txt b/BigFile.txt
deleted file mode 100644
index 6907c67..0000000
--- a/BigFile.txt
+++ /dev/null
@@ -1 +0,0 @@
-a big file

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git log --stat -2
commit fe2ddd087ee22c4ab3a58eff4c1e27b5c4bfa5a2 (HEAD -> master)
Author: yunk <1052433260@qq.com>
Date:   Wed Apr 14 20:05:15 2021 +0800

    update gitignore

 .gitignore | 2 ++
 1 file changed, 2 insertions(+)

commit 403566622121ba571ca3b49823fafe9e0a0d1b91
Author: yunk <1052433260@qq.com>
Date:   Wed Apr 14 20:03:38 2021 +0800

    not track Bigfile

 BigFile.txt | 1 -
 1 file changed, 1 deletion(-)

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git log --pretty=oneline -2
fe2ddd087ee22c4ab3a58eff4c1e27b5c4bfa5a2 (HEAD -> master) update gitignore
403566622121ba571ca3b49823fafe9e0a0d1b91 not track Bigfile

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git log --pretty=format:"%h - %an, %ar : %s"
fe2ddd0 - yunk, 3 minutes ago : update gitignore
4035666 - yunk, 5 minutes ago : not track Bigfile
455b35d - yunk, 6 minutes ago : add a big file
8d4fa5f - yunk, 14 minutes ago : this is a commit for something
676fa8d - yunk, 25 minutes ago : init project

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git log --pretty=format:"%h %s" --graph
* fe2ddd0 update gitignore
* 4035666 not track Bigfile
* 455b35d add a big file
* 8d4fa5f this is a commit for something
* 676fa8d init project
```

### 撤销操作 ###

撤销暂存的文件: `git reset HEAD <file>...`

撤销对文件的修改： `git checkout -- <file>`

### 远程仓库 ###

查看远程仓库： `git remote -v`

添加远程仓库： `git remote add <shortname> <url>`

从远程仓库中抓取： `git fetch <remote>`

推送到远程仓库： `git push <remote> <branch>`

查看某个远程仓库的详细信息： `git remote show origin`

## 2. 分支 ##

当提交三个文件时，且文件都在根路径下面时，git中对象的结构为：

五个对象：三个 *blob* 对象（保存着文件快照）、一个 **树** 对象 （记录着目录结构和 blob 对象索引）以及一个 **提交** 对象（包含着指向前述树对象的指针和所有提交信息）。

![首次提交对象及其树结构。](.assert/commit-and-tree.png)

Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 `master`。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 `master` 分支。 `master` 分支会在每次提交时自动向前移动。

![分支及其提交历史。](.assert/branch-and-history.png)

### 分支的创建 ###

`git branch <branch_name>`

当执行该命令时，git会在当前的提交对象上创建一个指针，指向该提交对象。

![两个指向相同提交历史的分支。](.assert/two-branches.png)

那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 `HEAD` 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 `HEAD` 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 `HEAD` 想象为当前分支的别名）。 

![HEAD 指向当前所在的分支。](.assert/head-to-master.png)

使用 `git log` 命令查看各个分支当前所指的对象。 

```shell
$ git log --oneline --decorate
8002d09 (HEAD -> dev1) update file1
980d256 (master) add new files
fe2ddd0 (origin/master) update gitignore
4035666 not track Bigfile
455b35d add a big file
8d4fa5f this is a commit for something
676fa8d init project
```

### 分支切换 ###

`git checkout  <branch_name>`

移动 `HEAD` 指针的指向。HEAD会随着提交操作自动向前移动。

**查看分叉历史**

```shell
$ git log --oneline --decorate --graph --all
* 71ab65a (HEAD -> master) modify file2
| * 8002d09 (dev1) update file1
|/
* 980d256 add new files
* fe2ddd0 (origin/master) update gitignore
* 4035666 not track Bigfile
* 455b35d add a big file
* 8d4fa5f this is a commit for something
* 676fa8d init project
```

创建新分支并切换过去： `git checkout  -b <new_branch>`

### 分支的合并 ###

```shell
$ git merge hotfix
Updating 763b82c..1428611
Fast-forward
 file1.txt | 2 ++
 1 file changed, 2 insertions(+)
```

1.当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “**快进（fast-forward）**”。

2.另一种种情况下，你的开发历史从一个更早的地方开始**分叉开来（diverged）**。 因为，`master` 分支所在提交并不是 `iss53` 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（`C4` 和 `C5`）以及这两个分支的公共祖先（`C2`），做一个简单的三方合并。

![一次典型合并中所用到的三个快照。](.assert/basic-merging-1.png)

Figure 24. 一次典型合并中所用到的三个快照

和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。

![一个合并提交。](.assert/basic-merging-2.png)

**冲突问题**：如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 

### 分支管理 ###

查看分支的最后一次提交：

```shell
$ git branch -v
* master f37a8a4 Merge branch 'dev1'
```

`--merged` 与 `--no-merged` 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。

```shell
Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git branch --merged
  dev1
* master

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git branch --no-merged
  dev2
```

 `-D` 强制删除分支。

### 远程分支 ###

可以通过 `git ls-remote <remote>` 来显式地获得远程引用的完整列表， 或者通过 `git remote show <remote>` 获得远程分支的更多信息。

**远程跟踪分支是远程分支状态的引用**。它们是你**无法移动的本地引用**。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你**最后一次连接到它们的位置**。以 `remote/branch` 的形式命名。

![克隆之后的服务器与本地仓库。](.assert/remote-branches-1.png)

```shell
Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git fetch origin
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 281 bytes | 40.00 KiB/s, done.
From https://gitee.com/libyao/git-demo
   55e9325..640d785  master     -> origin/master

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git merge origin/master
Updating 55e9325..640d785
Fast-forward
 file_demo.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 file_demo.txt

```

**推送分支**

`git push <remote> <branch>`

**远程分支的相关操作**

创建远程跟踪分支： 

`git checkout -b serverfix origin/serverfix`

`git checkout --track origin/serverfix`

从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 `git pull`，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。

设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 `-u` 或 `--set-upstream-to` 选项运行 `git branch` 来显式地设置。

**更改本地对远程分支的追踪**

`git branch -u origin/serverfix`

```shell
$ git branch -a
  dev1
  dev2
* master
  remotes/origin/dev1
  remotes/origin/dev2
  remotes/origin/feature/demo1
  remotes/origin/master

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (master)
$ git checkout dev1
Switched to branch 'dev1'

Liberty@LAPTOP-P85CKKBA MINGW64 ~/Downloads/packages/timeline-20210414/git-demo (dev1)
$ git branch -u origin/dev1
Branch 'dev1' set up to track remote branch 'dev1' from 'origin'.
```

### 分支变基 rebase ###

![分叉的提交历史。](.assert/basic-rebase-1.png)

其实，还有一种方法：你可以提取在 `C4` 中引入的补丁和修改，然后在 `C3` 的基础上应用一次。 在 Git 中，这种操作就叫做 **变基（rebase）**。 你可以使用 `rebase` 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。

在这个例子中，你可以检出 `experiment` 分支，然后将它变基到 `master` 分支上：

```console
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
```

它的原理是首先找到这两个分支（即当前分支 `experiment`、变基操作的目标基底分支 `master`） 的最近共同祖先 `C2`，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 `C3`, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）

![将 `C4` 中的修改变基到 `C3` 上。](.assert/basic-rebase-3.png)

现在回到 `master` 分支，进行一次快进合并。

```console
$ git checkout master
$ git merge experiment
```

![`master` 分支的快进合并。](.assert/basic-rebase-4.png)

## 3. git 工具 ##

